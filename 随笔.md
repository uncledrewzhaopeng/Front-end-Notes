### 11.21

##### 函数的概念及其定义方式

```js
// 函数概念：把具有特定功能的独立代码块封装，形成一个实体（函数），起个名字（函数名），函数后期可以反复调用
// 函数作用：函数可以封装代码，实现代码复用，让程序变得简洁、高效
// 函数定义（两种）
	1、函数的声明
    function 函数名() {
        
    }
	2、函数表达式
    var aa = function() {
        
    }
```

##### 函数的调用

```javascript
// 函数有很多种调用方式
1 直接调用 函数名()
2 事件调用 onclick = function(){} onmouseover = function(){}
```

##### 函数的分类

```javascript
    分类方式1：
    	系统内置函数 alert() parseInt() // function alert(){}
    	用户自定义函数 function abc() {}
    分类方式2：
    	有名函数
        匿名函数 === 匿名函数无法直接调用，可以通过匿名函数自调用来实现
    	(function (a){
            alert(a);
        })(24);
    函数的立即执行表达式
```

##### 函数的传参

```javascript
    //函数的参数
    function fun1(a,b,c) { // a b c 形参：函数在定义的时候写的参数
        // 形参相当于局部变量
    }
    fun1("你好","哈哈","呵呵"); 实参：函数在调用的时候写的参数
    参数是一一对应的 接收的
    参数可以写多个
    如果实参 多于 形参；多余的那个实际参数就没用了
    如果形参 多于 实参； 多余的形参值为 undefined
```

##### 作用域与预解析（变量提升）


```javascript
作用域：（当前变量/形参或者函数）起作用的区域；
    全局作用域 全局函数 全局变量
    局部作用域 （函数可以形成局部作用域）局部变量 局部函数
js语言：通过浏览器的js解释器执行的
那么这个解释器的意思：
	// 第一步预解析：（找找当前作用域下没有声明的变量（形参）和声明的函数）如果同名冲突了，函数级别高于变量，级别一样高，后者覆盖前者
    // 第二步代码执行：按照自上而下的顺序执行
```



##### 创建函数：

```javascript
  1、先开辟一个新的内存空间（为其分配一个16进制的地址）

  2、把函数体中编写的js代码当做'字符串'存储到空间中（函数只创建不执行没有意义）

  3、把分配的地址赋值给声明的函数名（function fn和 var fn操作原理其实相同，都是在当前作用域中声明了一个名字，此处两个名字是重复的）
```



##### 执行函数：

```javascript
  目的：执行函数体中的代码

  1、函数执行的时候，浏览器会形成一个新的私有作用域（只能执行函数体中的代码）供函数体中的代码执行

  2、执行代码之前先把创建函数存储的那些字符串变成真正的js表达式，按照从上倒下的顺序在私有作用域中执行

	一个函数可以被执行n次，每一次执行相互之间互不干扰（后面会学习两者之间建立的直接关系）

	形成的私有作用域把函数体的函数私有变量等都包裹起来了（保护起来了），在私有作用域中操作私有变量和外界没有关系，外界也无法直接的操作私有变量，我们把函数执行形成的这种保护机制叫做“闭包”。
```

```javascript
 function fn() {
  	var ary = Array.prototype.slice.call(arguments);
  	return eval(arr.join('+'))
}
```



##### JS中的堆栈内存

```javascript
	栈内存：

​		俗称叫做作用域（全局作用域/私有作用域）

​		为JS代码提供执行的环境（执行JS代码的地方）

​		基本数据类型值是直接存放在栈内存中的

	堆内存：

​		存储引用数据类型值的（相当于一个存储的仓库）

​		对象存储的是键值对

​		函数存储的是代码字符串

​		在项目中，我们的内存越少性能越好，我们需要把一些没用的内存处理掉；


	[堆内存]

​	var o = {};当前对象对应的堆内存被变量o占用着，堆内存是无法销毁的

​	o = null;null空对象指针（不指向任何的堆内存），此时上一次的内存就没有被占用了，谷歌浏览器会在空闲时间把没有占用的堆内存自动释放（销毁/回收）；


	[栈内存]

​	一般情况下，函数执行形成栈内存，函数执行完，浏览器会把形成的栈内存自动释放；有时候执行完成，栈内存不能被释放？

​	全局作用域在加载页面的时候执行，在关掉页面的时候销毁；
```



##### 变量提升（预解释）

```javascript
	在 ‘当前作用域’ 中，js代码自上而下执行之前，浏览器首先会把所有带 ‘var/function’ 关键字的进行提前的声明或者定义；

​	声明（declare）：var num；在当前作用域中吼一嗓子我有num这个名了；

​	定义（defined）：num=12；把声明的名字赋给一个值；

​	带var关键字的只是提前的声明一下；

​	带function关键字的在变量提升阶段把声明和定义都完成了；
```

```javascript
    console.log(num);
    console.log(fn);
    //fn();//->放在前面执行也可以
    var num = 13;
    function fn() {
        console.log(a);
        var a = 10;
        console.log(a);
    }
    fn();
    console.log(num);
```



##### 作用域链

```javascript
	局部的变量和函数，在使用的时候如果局部没有声明，他会沿着一个（隐形的链条向上找变量和函数）由里向外逐层找，本着就近原则，这样一个查找链条就是作用域链
```

​	![1574321033061](C:\Users\97201\AppData\Roaming\Typora\typora-user-images\1574321033061.png)



##### 函数内部的三个小东西：

```javascript
	一、arguments （在函数内部，自动存储，当前函数传入的实际参数，它是一个集合）

​		应用场景：适合参数个数不确定的情况下

​		比如：求任意个数的最大值

​			 求任意个数的和		

​	二、this 指向（这个代词 当前函数被谁调用 this就指向谁）

​		1、函数如果直接调用，内部的this指向window对象

​		2、函数如果被事件调用，内部的this指向触发该事件的前面的那个元素

​	三、return（返回值）的特点：

​		1、return 可以返回任何数据类型

​		2、return 返回返回值之后，后面代码不执行，函数终止

​		3、return 默认返回undefined
```



#####  函数中的this

```javascript
function fn() {
        console.log(this);//这个  代词 this到底是谁 取决于当前函数被谁调用
        // 谁调用我的函数 我this就指向谁
    }
    fn(); // 直接调用 this===>window(window对象是js中的顶级对象)
    
    // 函数的调用方式 1 直接调用 2 事件调用
    // document 文档对象
    document.getElementById('box').onclick = function() {
        (this);// 事件调用函数 函数内部的this 指向触发该事件的前面的那个元素
    }
```

##### 函数中的arguments


```javascript
// arguments:实际参数的集合
// 当前函数调用的时候 实际传入的参数 都会被这个哥们存起来
// 求最大值
// 求任意个数中谁最大
function getMax() {
    // console.log(arguments);// [4,12,-3] 集合 类似于数组（不是数组）
    // console.log(arguments.length);
    // console,log(arguments[1]);
    // console.log(arguments[arguments.length]);
    // 这个集合 有length长度
    
    // 设置一个最大值
    // Infinity 无穷大
    // -Infinity 无穷小
    var maxNum  = -Infinity;
    for(var i = 0;i < arguments.length;i++) {
        // 谁比我大 我就是谁
        if(maxNum <arguments[i]) {
           maxNum = arguments[i];
        }
    }
    alert(maxNum);
}
// 实际参数 个数不确定
// getMax(14,8,2);
getMax(6,48,-3,-25,100);

// 求和
function getAdd(){
 	var sum = 0;
    for(var i = 0;i < arguments.length;i++){  
       sum += arguments[i];
   }
    alert(sum);
}
getAdd(1,2,3,5,6);
```



##### 代码重用的原则：

```javascript
	1、尽量保持HTML结构的一致性，可以通过父级选取子元素

​	2、把核心主程序实现，用函数包起来

​	3、把每组里不同的值找出来，通过传参实现
```



### 11.22

##### 递归函数：函数自身调用自身的编程技巧

```javascript
// 递归函数需要给递归的条件为了某一刻终止递归（给他一个出口）
var num = 0;
function tellStory() {
    console.log(num: + "123");
    num++;
    if(num <= 10) {
        tellStory();
    }
}
tellStory();

/**
求阶乘
5!=5*4*3*2*1
n!=n*(n-1)*(n-2)...*2*1
**/
function qiujiecheng(n) {
    if(n == 1) {
        return 1;
    }
    return n * qiujiecheng(n-1);
}
var result = qiujiecheng(12);
console.log(result);

/*
兔子问题（斐波那契数列）
斐波那契数列 1 1 2 3 5 8 13 21 34 55 递归函数
*/
function Fb(n) {
    if(n <= 2) {
        return 1;
    }
    return Fb(n-1) + Fb(n-2);
}
var result = Fb(12);
console.log(result);
```



##### 数组

```
数组：存储多条数据 数据类型 大仓库
[[1,2,3],["",""]]
```

###### 数组的四个小方法及其它方法

```javascript
// push() unshift() shift() pop()
/*
push:
定义：从数组的末尾添加一个或多个元素
参数：一个或者多个元素
返回值：改变后的数组长度
原数组是否发生改变：原数组改变了
*/
var arr = ["赵四","刘能","小沈阳"]
var result = arr.push("宋小宝")；
console.log(arr);
console.log(result);

/*
pop:
定义：从数组的末尾删除一个元素
参数：无
返回值：删除后的那个元素
原数组是否发生改变：原数组改变了
*/
var arr2 =["赵四","刘能","小沈阳","宋小宝"];
var ret = arr2.pop();
console.log(ret);

/*
unshift:
定义：从数组的开始位置添加一个或者多个元素
参数：一个或者多个元素
返回值：改变后的数组的长度
原数组是否发生改变：原数组改变了
*/
var arr3 = ["1","2","3","4"];
var ret = arr3.unshift("5");
consoloe.log(arr3);
console.log(ret);

/*
shift:
定义：从数组的开始位置删除一个元素
参数：无
返回值：删除后的那个长度
原数组是否发生改变：原数组改变了
*/
var arr4 = ["1","2","3","4","5"];
var ret = arr4.shift();
console.log(arr4);
console.log(ret);

===========================其它数组方法==============================
/*
splice:
定义：删除方法（删除 修改 添加）
参数：
	1 开始删除元素的位置
	2 删除元素的个数 默认删除到最后
	3 需要添加元素的个数
返回值：删除后的元素，组成的新的数组
原数组是否发生改变：原数组改变了
*/
var student = ["小明","小马","小孩","小红"];
var ret = student.splice(1);
console.log(student);
console.log(ret); // 新的数组[]

/*
slice:
定义：截取方法
参数：
	1 开始截取的位置
	2 结束截取的位置（不包含结束位置）
返回值：截取后的元素，组成的新的数组
原数组是否发生改变：原数组不会发生改变
*/
var arr = ["1","2","3","4"]；
var ret = arr.slice(1,3);
console.log(arr);
console.log(ret);// ["2","3"]

/*
concat:
定义：用来连接数组或者其它元素，合并数组/元素
参数：数组或者是元素
返回值：连接后的数组
原数组是否发生改变：原数组不会发生改变
*/
var stu1 = ["1","2","3","4","5"];
var stu2 = ["6"];
var stu3 = "7";
var ret = stu1.concat(stu3,stu2);
console.log(stu1);
console.log(ret);

/*
indexOf:(从左往右找)
lastIndexOf:(从右往左找)
定义：查找数组中的元素
参数：
	1 需要找的元素
	2 开始查找的位置
返回值：返回下标的位置
	   如果找到则返回下标位置
	   如果没找到则返回 -1
原数组是否发生改变：原数组不会发生改变
*/
var stu1 = ["1","2","3","4","5"];
var ret = stu1.indexOf("2",2)
var ret = stu1.lastIndexOf("3")
console.log(stu1);
console.log(ret);

/*
reverse:
定义：翻转数组
参数：无
返回值：翻转后的数组
原数组是否发生改变：原数组会发生改变
*/
var stu1 = ["1","2","3","4","5"];
var ret = arr.reverse();
console.log(ret);

/*
sort:
定义：排序方法
参数：无
返回值：排序后的数组
原数组是否发生改变：原数组会发生改变
*/
var arr = [5,8,34,28,13];
var ret = arr.sort(function(a,b) {
    return a - b;
});// 字符串规则进行排序，字符串的编码进行逐位比较
console.log(ret);

// 随机打乱
var arr = [5, 8, 13, 28, 34];
var ret = arr.sort(function() {
    return Math.random() - 0.5 // 0-1随机小数
})
console.log(ret);

/*
join:
定义：可以将数组转换为字符串，通过一个连接符
参数：连接符
返回值：字符串
原数组是否发生改变：原数组不会发生改变
*/
var arr = ["1","2","3","4","5"];
var ret = arr.join('-');
console.log(ret);// 1-2-3-4-5 
console.log(typeof ret);// string
```



##### 冒泡排序

```js
冒泡排序:是一种排序算法
	其它的算法还有(快速排序、选择排序、二叉树、时间复杂度等)
/*
原数组 4  5  2  3  1

第一轮 4  2  3  1  5 比较了四次 （4-5 5-2 5-3 5-1）
第二轮 2  3  1  4  5 比较了四次 （4-2 4-3 4-1 4-5）
第三次 2  3  1  4  5 比较了四次 （2-3 3-1 3-4 4-5）
第四轮 1  2  3  4  5 比较了四次 （1-2 2-3 3-4 4-5）
*/
var arr = [4,5,2,3,1];
// 循环遍历数组
// 初级版
for(var i = 0;i < arr.length-1;i++) {// 外层循环控制的是比较的轮数
	for(var k = 0;i < arr.length-1;k++) {// 内存循环控制的是每轮比较的次数
		// 两两相邻比较
		// 如果前一个数大于后一个数
        if(arr[k] > arr[k+1]) {
            // 交换位置
            // 设置一个临时变量，用来存第一个数据
            var temp = arr[k];
            arr[k] = arr[k+1];
            arr[k+1] = temp; 
        }
    }
}
console.log(arr);
=========================================================
function mp(arr) { // 升级版
    var cishu = 0;
    for(var i = 0;i < arr.length;i++) {// 外层循环控制的是比较的轮数
    	for(var k = 0;i < arr.length-1-i;k++) {// 内存循环控制的是每轮比较的次数
        	// 两两相邻比较
            // 如果前一个数大于后一个数
        	if(arr[k] > arr[k+1]) {
            // 交换位置
            // 设置一个临时变量，用来存第一个数据
            	var temp = arr[k];
            	arr[k] = arr[k+1];
            	arr[k+1] = temp;
        	}
            cishu++;
    	}
	}
console.log(arr);
console.log("总共比较了" + cishu + "次");
}
=========================================================
function mp(arr) { // 旗舰版
    var cishu = 0;
    var lunshu = 0;
    for(var i = 0;i < arr.length;i++) {// 外层循环控制的是比较的轮数
        var onOff = true；
    	for(var k = 0;i < arr.length-1-i;k++) {// 内存循环控制的是每轮比较的次数
        	// 两两相邻比较
            // 如果前一个数大于后一个数
        	if(arr[k] > arr[k+1]) {
            // 交换位置
            // 设置一个临时变量，用来存第一个数据
            	var temp = arr[k];
            	arr[k] = arr[k+1];
            	arr[k+1] = temp;
                onOff = false;
        	}
            cishu++;
    	}
        lunshu++;
        if(onOff == true) {
            break;
	}  
console.log(arr);
console.log("总共比较了" + cishu + "次");
console.log("总共比较了" + lunshu + "轮");
}
```



##### 字符串：可读不可写

```js
/*
字符串，charAt();在该字符串中，根据下标找相对字符
*/
var str1 = "helloworld";
var ret = srt1.charAt(4);
console.log(str1); 
console.log(ret);

/*
字符串，charCodeAt();在该字符串中，根据下标找对应字符的字符编码
*/
var str2 = "你好世界";
var ret = srt2.charAt(2);
console.log(str2); 
console.log(ret);

/*
字符串，String.fromCharCode();在该字符串中，根据对应的编码返回对应的字符
*/
var ret = String.fromCharCode(19990);
console.log(ret);

==================================================  
<body>
   你要说的话：<input type="text" id="text1">
   <input type="button" value="单击加密" id="btn">
   <br>加密后的文字：<div id="box"></div>
   <input type="button" id="btn2" value="单击解密">
</body>
<script>
    var oText = document.getElementById("text1");
	var oBtn = document.getElementById("btn");
	var oBox = document.getElementById("box");
	var oBtn2 = document.getElementById("btn2");
    /*
    单击按钮把文本框中输入的文字内容进行加密并弹框
    加密，把这段文字里面的每一个字都进行转换为字符编码然后进行加减运算
    */
     //给按钮添加点击事件
     oBtn.onclick = function() {
       // 获取文本框中的内容
       var str = oText.value;
       // 设置一个新的字符串，把新的字符拼接起来
       var newStr = "";
       for(var i = 0;i <  str.length;i++) {
           //循环字符串，操作每一个字符
           var code = str.charCodeAt(i);
           newStr += String.fromCharCode(code - 1314);
       }
       //alert(newStr);
       oBox.innerHTML = newStr;
   }

// 解密
oBtn2.onclick = function() {
    // 从大盒子当中去获取加密后的文字
    var text = oBox.innerHTML;
    // 用一个新的字符串，把新的字符拼接起来
    var newStr = "";
    // 循环字符串
    for(var i = 0;i < text.length;i++) {
        var code = text.charCodeAt(i);// 把每个字符转换成对应的编码
        newStr = String.fromCharCode(code + 1314);
    }
    //alert(newStr);
    oBox.innerHTML = newStr;
}
</script>
 
```



###### 字符串查找方法

```js
/*
indexOf:(从左往右)
lastIndexOf:(从右往左)
定义：
	在字符串当中，查找相应的字符
	如果找到了则返回对应的下标/索引
	如果找不到则返回 -1
参数：1 需要查找的字符 2 开始查找的位置(默认从0开始找)		
*/
var str1 = "前端开发";
var ret = str1.indexOf("开");
console.log(ret);// 2

var ret2 = str1.lastIndexOf("开");
console.log(ret2);// 2
```



###### 字符串截取方法

```js
/*
substring:截取方法
参数：1 开始截取的位置 (默认从0开始)
	 2 结束截取的位置(不包含结束位置) 默认到最后
*/
var str1 = "helloworld";
var ret = str1.substring(5,1);
console.log(ret);// ello

/*
slice:截取方法
参数：1 开始截取的位置 (默认从0开始)
	 2 结束截取的位置(不包含结束位置) 默认到最后
*/
var str1 = "helloworld";
var ret = str1.slice(5,1);
console.log(ret);// 

/*
substring和slice的区别：
	1 substring 支持参数颠倒顺序，会自动颠倒顺序
      slice 不支持颠倒顺序
    2 substring 把负数当成0来处理
      slice 支持负数
*/   
```



###### 大小写字母转换

```js
var str1 = "abCDeFgyHHhA2HS1ka你jDd好";
var ret = str1.toUpperCase();// 小写字母转大写字母
console.log(ret);
var ret = str1.toLowerCase();// 大写字母转小写字母
console.log(ret);
```



###### 字符串split方法

```js
split():字符串方法，将字符串通过分割符转换为数组
参数：分割符
var srt1 = "2019-8-16";// ["2019","8","16"]
var ret = str1.split('-');
console.log(ret);

// 面试题
var text = "abcdefg";
text.split("").reverse().join("");
```



##### 获取日期时间

```js
console.log(new Date()); // Fri Nov 22 2019 17:21:27 GMT+0800 (中国标准时间)
console.log(typeof (new Date())); // object
var mydate = new Date();
// 获取年
var year = mydate.getFullYear();
console.log(year);
// 获取月
var month = mydate.getMonth();
console.log(month);
// 获取日
var date = mydate.getDate();
console.log(date);
// 获取星期
var week = mydate.getDay();// 1 2 3 4 5 6 0
console.log(week);
// 获取小时
var hour = mydate.getHours();
console.log(hour);
// 获取分钟
var min = mydate.getMinutes();
console.log(min);
// 获取秒
var sec = mydate.getSeconds();
console.log(sec);
// 获取毫秒 1000ms = 1s
var ms = mydate.getMilliseconds();
console.log(ms);
```

##### 显示日期时间

```js
function getTime() {
	var mydate = new Date();
	var year = mydate.getFullYear();
	var month = mydate.getMonth();
	var date = mydate.getDate();
	var week = mydate.getDay();
	var hour = mydate.getHours();
	var min = mydate.getMinutes();
	var sec = mydate.getSeconds();
	var ms = mydate.getMilliseconds();
// 把星期处理一下
switch(week) {
    case 1:
        week = "星期一";
        break;
    case 2:
        week = "星期二";
         break;
    case 3:
        week = "星期三";
         break;
    case 4:
        week = "星期四";
         break;
    case 5:
        week = "星期五";
         break;
    case 6:
        week = "星期六";
         break;
    case 7:
        week = "星期日";
         break;
}

	var str = year + "年" month + "月" + date + "日" 
    			+ week +  "星期" + hour "：" + min "：" + sec "：" + ms;
	document.body.innerHTML = "<h1>" + str + "</h1>"
}
// 定时器
setInterval(getTime,1000)

```



### 11.25

##### Math数学方法

```js
程序，数学计算，内置数学对象Math，提供给外面很多数学方法
var num1 = 3.8;
// Math.round() ===> 四舍五入
console.log(Math.round(num1));

// Math.floor() ===> 向下取整
console.log(Math.floor(num1));

// Math.ceil() ===> 向上取整
console.log(Math.ceil(num1));

// Math.max() ===> 最大值
console.log(Math.max(3,6,12,8,-3)); // 12

// Math.min() ===> 最小值
console.log(Math.min(3,6,12,8,-3)); // -3

// Math.pow(x,y) ===> 求x的y次方
console.log(Math.pow(2,10)); // 1024

// Math.sqrt() ===> 开平方根
console.log(Math.sqrt(9)); // 3

// Math.abs() ===> 求绝对值
console.log(Math.abs(-4)); // 4

Math.sin() // 正弦
Math.cos() // 余弦
Math.tan() // 正切

// Math.PI ===> 常量
console.log(Math.PI;

// Math.random() ===> 产生一个随机数 0-1随机小数(包含0.不包含1)
console.log(Math.random());

```

###### Math.random随机数

```js
// 0-10 随机整数
var str = "";
for(var i = 0;i < 100;i++) {
    var num = Math.round(Math.random()*10); // 0-1 直接随机小数 包含0.不包含1
	if(num == 0) {
        str += "<strong style="font-size:30px;">" +num+ "&nbsp;&nbsp;</strong>";
    }else{
        str += num + "&nbsp;&nbsp;";
    }
	if(i % 20 == 0) {
		str += "<br>"
	}
}
document.body.innerHTML = str;

// x-y 之间随机整数
Math.round(Math.random()*(y-x)) + x;
```



###### 生成验证码方法

```js
// 求四位随机数字(可以重复)
// 方法1
var str = "";
//产生 0-9 之间随机整数
for(var i = 0;i < 4;i++) {
	str += Math.round(Math.random()*9);
}

// 方法2
var num = Math.round(Math.random()*9999);
var result = zero(num); // 0-9999随机整数 

// 方法3
var arr = [1,2,3,4,5,6,7,8,9,0];
var str = "";
// 这是第三种方法，可以数组重复的
for(var i = 0;i < 4;i++) {
	arr.sort(function() {
	return Math.random() - 0.5;
	})
	str += arr[0];
}
// str是最后结果

// 不重复
arr.sort(function() {
    return Math.random() - 0.5;
})
// 截取数组中的前四位，通过join方法使用空字符串链接转成字符串
var result = arr.slice(0,4).join("");
```



##### js对象

```js
// js对象定义：
// 1 {}
	var obj1 = {
		//键名：键值 键名唯一
		age:24,
		name:"张三"，
		job:"舞者"
	}
// 2 new object
	var obj2 = new object(); // obj是一个对象
	// js对象.键 = 你给设置的键值 
	obj2.name = "李四";
	obj2.age = 45;
	obj2.job = "演员";
```

###### 注意：

```js
1、js对象中，键名唯一

2、里面键值对的无序的

3、读取键值：对象名称.键名 ==>键值

4、设置键值 对象名.键名 = 键值

5、[] 可以代替点 对象名["键名"]

​		obj2.name = "李四";

​		obj2["name"] = "李四";
```



### 11.26

###### 批量创建对象(工厂函数)

```js
function createStudent(name,age) {
	// 1 通过new方式，创建一个空白对象
    var stu1 = new object();// 局部
    // 2 给当前的对象添加了一个属性名name 值name(这个name是形参，用来接收外部传入的值)
    // 给对象添加一个name属性
	stu1.name = name;
    // 给对象添加一个age属性
	stu1.age = age;
    // 给对象添加方法
	stu1.coding = function() {
        console.log("喜欢写bug");
    }
    stu1.playGame = function() {
        console.log("玩游戏");
    }
    // 返回对象
    return stu1;
}
var stu1 = createStudent("张三",23);// 全局
console.log(stu1.name);
console.log(stu1.age);
stu1.coding();

createStudent("李四",25);
createStudent("老王",38);
```

###### 批量创建对象(构造函数)

```js
构造函数

​	1 需要靠new 调用

​	2 构造函数名称 首字母大写 UserName

​	3 内部不需要创建对象，也不需要返回对象，把需要的属性方法和方法给this加

new的一个过程

​	1 内存中开辟空间，把创建好的对象存入其中

​	2 把当前创建好的对象，赋给函数内部的this

​	3 给this身上添加属性（特征）方法（行为）

​	4 返回当前的this（创建好的对象）

通过 new 来调用构造函数，就是一个实例化的过程
stu1 就是一个实例化对象
```

```js
function CreateStudent(name,age) {
    // 给当前的对象添加了一个属性名name 值name(这个name是形参，用来接收外部传入的值)
    // 给对象添加一个name属性
	this.name = name;
    // 给对象添加一个age属性
	this.age = age;
    // 给对象添加方法
	this.coding = function() {
        console.log("喜欢写bug");
    }
    this.playGame = function() {
        console.log("玩游戏");
    }
}
var stu1 = new CreateStudent("小王",25);
var stu2 = new CreateStudent("小红",21);
console.log(stu1.name);
console.log(stu1.age);
stu1.coding();
```

###### json

```json
json(javascript object notation): js对象标记语法 数据格式
严格意义上：键名必须用双引号引起来
json：一个轻量级的前后端数据交互格式（重量级 data.xml data.json）
前端： js对象 == json （json字符串 ==> js对象）

{
"a":3,
"b":"hehe"
}
```

###### js对象的遍历方式

```js
for...in 循环语句，遍历我们的对象
for(var k in 对象) {
	k:对象中的每一个键名
	对象[k]:对象中的每一个键值
}
对象：无序属性（方法）的集合
数组属于特殊的对象，因为它的键名是下标（有序的 0 1 2...）
数组：for循环 for in去循环
普通对象：只能用for in循环，无法用for循环
```



##### 值类型和引用类型的区别

![image-20191126113609965](C:\Users\97201\AppData\Roaming\Typora\typora-user-images\image-20191126113609965.png)

```js
var a = 10;
var b = a;
b += 3;
console.log(a);
console.log(b);

var ee = ["hello","靠你起哇","萨瓦迪卡"];
var ff = ee;
ff.push("空吧哇");
console.log(ee);
console.log(ff);
```



##### 封装样式的函数

````js
var oBox = $('#box');
var oSpan = $('span')[0];
// 各个浏览器都适用
function getStyle(ele,attr) {
	if(ele.currentStyle) {
		return ele.currentStyle[attr];
	}else{
		return getComputedStyle(ele)[attr];
	}
}
var result1 = getStyle(oBox,"width");
var result2 = getStyle(oBox,"backgroundColor");
console.log(result1,result2);
var result3 = getStyle(oSpan,"border");
console.log(result3);
````

##### 获取元素的函数 

```js
function $(selector,parent) {
	// parent是形参，没有接收值 undefined 没有传值就按默认来document
	parent = parent || document;
	if(selector.charAt(0) === "#") {
		return document.getElementById(selector.slice(1));
	}else{
		return parent.getElementByTagName(selector);
	}
}
// document
var oUl = $('ul')[0];
var oLi = $('li'); 
for(var i = 0;i < aLi.length;i++) {
    aLi[i].style.backgroundColor = "blue";
}
```



##### js组成

```js
JavaScript：ECMAScript DOM
DOM：document object model 文档对象模型
规定了一套如何操作页面html元素的相关属性和方法的API
模型：对网页文档对象的一种抽象性的概括 ===> 文档树 DOM树模型
window 顶级对象
document 文档对象
API：application programming interface 应用程序的编程接口 广义
狭义：一系列属性和方法
```



##### DOM节点类型

```js
元素节点 nodeType 1
属性节点		  2
文本节点		  3
注释节点		  8
文档节点document  9
文本类型声明<!docType html> 10

// 子节点
childNodes：获取某个元素下的直接子节点（不包含孙级节点）
children：获取某个元素下的直接子节点（不包含孙级节点）不是W3C官方标准属性，但是却被各大浏览器厂商识别没有兼容性问题（推荐使用）

// 第一个孩子/最后一个孩子
firstChild 获取第一个子节点：
	标准浏览器下：第一子节点（空白 元素 注释..）
	IE 6 7 8：只识别元素节点
firstElementChild:
	标准浏览器下：只获取元节点
	IE 6 7 8 不识别

lastChild：获取最后一个子节点
	标准浏览器下：可以识别空白文本节点，注释元素类型节点（不太好）
lastElementChild：这个是只针对标准浏览器下，只识别第一个元素类型的子节点，但是IE6 7 8不识别

// 前一个兄弟节点/后一个兄弟节点
previousSibling：获取前一个兄弟节点
	标准浏览器下：可以识别 文本节点 注释 元素节点（有可能获取错 不太好）
    IE 6 7 8只识别元素节点
previousElementSibling：获取前一个兄弟节点 标准浏览器中的属性
	IE 6 7 8不识别
// 用来获取前一个兄弟节点的函数（处理了兼容性）
function prew(ele) {
    var prevEle = ele.previousElementSibling || ele.previousSibling
    if(prevEle && prevEle.nodeType == 1){
        return prevEle;
    }else{
        return null;
    }
}
if(prev(li)) {
    prev(li).style.backgroundColor = "green";
}

nextSibling：获取后一个兄弟节点
	标准浏览器下：可以识别 文本节点 注释 元素节点（有可能获取错 不太好）
    IE 6 7 8只识别元素节点
nextElementSibling：获取后一个兄弟节点 标准浏览器中的属性
	IE 6 7 8不识别
// 用来获取前一个兄弟节点的函数（处理了兼容性）
function next(ele) {
    var nextvEle = ele.nextElementSibling || ele.nextSibling
    if(nextEle && nextEle.nodeType == 1){
        return nextEle;
    }else{
        return null;
    }
}
if(next(li)) {
    next(li).style.backgroundColor = "green";
}	

parentNode 父节点 没有兼容性问题

DOM中三个属性操作方法
getAttribute(名称)
setAttribute(名称,值)
removeAttribute(名称)

封装一个函数，实现各个浏览器的兼容
function first(ele) {
    var firstEle = ele.firstElementChild || ele.firstChild;
    // 只有一个空白文节点 nodeType == 1
    // firstEle 不能为空 假的
    if(firstEle && firstEle.nodeType == 1) {
   		return firstEle;    
   	}else{
       	return null;
   	}  
}
var result = first(ul);
if(result) {
    继续后续操作
}
```



##### 操作元素节点的方式

```js
> 创建DOM元素（标签节点）：js产生一个DOM元素
	createElement(标签名) 创建一个节点
	appendChild(节点)     追加一个节点
> 插入元素
	insertBefore(节点，原有节点) 在已有元素前插入
> 删除DOM元素
	removeChild(节点) 	删除一个节点
> 替换DOM元素
	replaceChild(节点，已有节点) 替换节点
> 克隆DOM节点
	cloneNode

添加元素：
第一种：innerHTML
	好处 1 可以给任何元素内部添加内容（标签文本） 2 可以不覆盖原有内容
	适合后期大量的字符串拼接（后端返回的数据都是字符串。需要拼接）
	innerHTML 性能比较差（一般解决方法 设置一个变量在内存中拼接，最后一次性innerHTML写入页面）会发生事件覆盖
第二种：document.write() 1 容易覆盖原有内容 2 不能往，某个元素中添加内容
第三种：createElement() 可以创建一个元素节点出来
```



### 11.27

##### BOM

> browser object model 浏览器对象模型
>
> 提供了一下JavaScript如何操作浏览器的一些属性和方法

```js
window 顶级对象
	document 文档对象
	navigator
	location
	screen
	...
	
	for(var k in window) {
		查看它身上的属性和方法，每个浏览器略有差异
	}
	
	open(参数1:url地址,参数2:打开方式)
	这个方法会返回新窗口的window对象
	close() 关闭窗口
	
	window.navigator.userAgent 用户代理信息，浏览器的详细信息
	判断是什么浏览器或者其它程序，访问网站，系统信息（可能不准确）
	
	window.location 地址栏操作
	window.location.href 完整的url地址
	location.hostname 主机名
	protocol 协议
	port 端口 80 443
	pathname 路径
	search 用来获取?后面的参数信息
	hash #后面的内容
	reload() 重启载入页面，可以加个true强制刷新
	
	history 历史记录
		back() 往回后退一个记录
		forward() 往前前进一个记录
		go() 指定数量 go(2) go(-1)
		
	screen 屏幕对象
		screen.height/width
		
	window下面的三个事件
	load加载事件 当浏览器程序全部加载完毕的时候，会触发该事件
	window.onload = function(){};
	resize事件 当窗口调整大小的时候会触发该事件
	window.onresize = function(){};
	scroll滚动事件，当滚动条滚动的时候触发该事件
	window.onscroll = function(){};	
```



##### 定时器

```js
// 第一个定时器 循环定时器 setInterval() === 清除定时器 clearInterval()
// 第二个定时器 延迟定时器 setTimeout() === 清除定时器 clearTimeout()

> setInterval() 它是一个函数也是一个方法，属于window下的这个定时器，只要你开了，它会永远存在
// 参数1：函数，大部分在用/字符串（可以执行的js语句）用的比较少
// 参数2：间隔时间，单位ms毫秒 1000ms == 1s
var num = 0;
function aa() {
    console.log(num + "123");
}
setInterval(aa,1000);

setInterval(function() {
    console.log("456");
},500)

// 用的不多，这个字符串里面必须是可以执行的js代码 === eval() 字符串解析 === 可以执行的js表达式
setInterval("console.log("789")",2000); 

setTimeout(function() {
    console.log("123");
},2000);
```



### 11.28

##### 焦点事件

```js
js的焦点事件：页面中有很多元素，有些元素可以参与用户的交互
input 文本框/密码框...
这些元素具备获取鼠标焦点的能力
// 让一个可以参与用户交互的元素获取焦点的方式有三种
// 1 鼠标直接点击
// 2 键盘的Tab
// 3 js获取焦点

// js自动获取焦点
oText.focus()
// js自动失去焦点
setTimeout(function() {
	oText.blur()
},3000);
```

##### 事件对象

```js
event：事件对象
当一个事件发生的时候，js会把关于当前发生的这个事件的详细信息存储在某个地方
如果你需要使用这些详细的信息，则可以直接获取使用
oBox.onclick = function(ev) { // 事件处理函数
    // window 顶级对象
    console.log(event);
    // 第一种方式获取：从全局window对象下的event中获取
    // 第二种方式获取：从事件处理函数中的第一个参数（默认就是事件对象）
    console.log(ev);
    // 谷歌两种方式都支持
    // 旧火狐只支持第二种方式，更新后的火狐都支持
    // IE9以上支持两种方式
    // IE6 7 8只支持第一种方式
}
```

##### 事件冒泡(先捕获后冒泡)

```js
事件冒泡：当一个事件发生的时候，会从该元素起步，逐渐向上传递，传递给父级们，知道window顶级对象为止
	这样一个事件冒泡传递过程，事件冒泡，事件冒泡当事件发生时就会默认执行（每一个父级元素都会收到冒泡事件）
	
阻止事件冒泡：在需要阻止向上冒泡的事件处理函数中，通过事件对象获取cancelBubble（默认为false）
	e.cancelBubble = true;
```

##### 事件委托(代理) === 原理(利用冒泡机制)

> 事件委托应用场景：内部子元素会动态变化，适合将子元素身上的事件委托给父级元素代理执行（性能更好）

> 事件流的三个阶段：事件捕获阶段、事件目标阶段、事件冒泡阶段

##### 事件绑定方式

```js
传统绑定方式：
onclick = function(){} onmouseover = function(){}
缺点：同一个元素，同一个事件，绑定不同的事件处理函数，后者会覆盖前者

新的绑定方式：(支持事件捕获、事件冒泡)
标准浏览器支持的
addEventListener 添加事件侦听器
元素.addEventListener(事件名称，事件处理函数，是否捕获)
	// 参数1：事件名称
	// 参数2：事件处理函数
	// 参数3：是否捕获
 
attachEvent() 这个方法是IE浏览器都支持 （只支持事件冒泡）
元素.attachEvent('on'+事件名称，事件处理函数)
	// 参数1：'on'+事件名称
	// 参数2：事件处理函数
	
封装一个兼容性函数
function bind(obj,evName,evFn) {
	if(obj.addEventListener) {
		obj.addEventListener(evName,evFn);
	}else if(obj.attachEvent) {
        obj.eventHandler = function() {
            evFn.call(obj);
        }
		obj.attachEvent("on" + evName,obj.eventHandler);
	}else{
		obj["on"+evName] = evFn;
	}
}
```

##### 事件解绑方式

```js
解绑方式：(支持事件捕获、事件冒泡)
标准浏览器支持的
removeEventListener 添加事件侦听器
元素.removeEventListener(事件名称，事件处理函数，是否捕获)
	// 参数1：事件名称
	// 参数2：事件处理函数
	// 参数3：是否捕获
 
detachEvent() 这个方法是IE浏览器都支持 （只支持事件冒泡）
元素.detachEvent('on'+事件名称，事件处理函数)
	// 参数1：'on'+事件名称
	// 参数2：事件处理函数
	
封装一个解绑兼容性函数
function unbind(obj,evName,evFn) {
	if(obj.removeEventListener) {
		obj.removeEventListener(evName,evFn);
	}else if(obj.detachEvent) {
		obj.detachEvent("on" + evName,obj.eventHandler);
	}else{
		obj["on"+evName] = null;
	}
}
```

##### 表单事件

```
onchange事件：当元素的值发生的时候，会触发该事件（必须焦点离开的时候触发，必须是值变化的时候才会触发）
oninput:输入事件，随着你的输入一直触发，搜索关键词/查询内容
```

##### 默认事件

```
当触发某个事件的时候，浏览器会自动完成某种行为
比如：a链接，滚动条按空格默认会滚动一屏，图片拖拽默认会打开图片...
```

##### 闭包

```js
js内存管理 自动垃圾回收机制 引用计数法 标记清除法
概念：在一个函数内部，定义一个函数，内部这个函数可以引用外部函数的变量或者参数，使该变量或者参数能够常驻内存，避免被垃圾回收机制所回收，那么当前内部的函数和外边引用的变量/参数整体合起来，称之为一个闭包环境
作用：1 将函数和变量私有化 代码功能开发 模块化 避免被全局污染
	 2 可以解决建立索引的问题

```



### 11.29

##### cookie

```js
cookie：前端的存储技术，浏览器缓存，一般用来存储少量数据 一般是以 KB 级别
cookie是http协议的一部分，它会在前后端数据交互过程中，携带(来往于前后端)session token
web端一般最常用的登录状态保持 cookie+session(token)
127.0.0.1 === localhost (本地回环测试地址 TCP/IP协议栈)本地服务器

// 封装一个设置cookie的函数
function setCookie(key,value,t) {
    var mydate = new Date();
    mydate.setDate(mydate.getDate() + t);
    document.cookie = encodeURI(key + "=" + value) +";expires=" + mydate;
}
// 为了防止 IE 或者其它一些浏览器对于中文或者特殊符号识别有问题，则需要把中文或者特殊符号进行编码存储，获取的时候再解码
// encodeURI() decodeURI()
setCookie("username","zs",3)
setCookie("username","ls",7)
setCookie("username","ww")
alert(docunment.cookie);


// 封装一个获取cookie的函数
'username=ls; password=12345; id=111'
var result = getCookie('username');
alert(result);

function getCookie(key) {
    var arr = decodeURI(document.cookie).split("; ");// ['username=ls','password=12345','id=111']
    for(var i = 0li < arr.length;i++) {
        var arr2 = arr[i].split("=");// 'username=ls' ==> ['username','ls']
        if(arr2[0] == key) {
            return arr2[1];
        }
    }
}


// 封装一个删除cookie的函数
removeCookie('username');
function removeCookie(key) {
    setCookie(key,'',-1); 
}
```



##### 面向对象

```js
面向对象三大特性：
	> 封装：函数（可以封装代码，使用者无需关心内部实现，只需要调用接口就可以）
		js面向对象：高度的封装（把一系列属性和方法封装起来）通过对象来调用，以对象为出发点来实现编程的
		面向过程：以过程为重，强调按部就班的去一步步的完成功能，前面一步骤没完成，后面无法继续，代码耦合度高，不利于大型项目的团队开发
	> 继承：子继承父
    	子类可以继承父类
	> 多态（抽象）
```

##### prototype原型

![image-20191129155209235](C:\Users\97201\AppData\Roaming\Typora\typora-user-images\image-20191129155209235.png)

```js
	JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的所拥有。
	这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在prototype对象上。
	function Person() {// 这是一个构造函数(类) ==> 对象
		this.name = name;
	}
	/*
	Person.prototype = {
		constructor:Person, // 构造器 === 指的是当前的构造函数
		// _proto_:
			fm:function() {
				console.log(this.name+ "bug");
			}
	}
	var p1 = new Person("zs"); // 实例化的过程，产生一个对象 p1(实例对象)
	p1.fm();
	var p2 = new Person(); 
	var p3 = new Person(); 
	*/
	Person.prototype.fm = function() {
        console.log(this.name+ "bug");
    }
```

##### 原型链搜索规则

![image-20191129161255985](C:\Users\97201\AppData\Roaming\Typora\typora-user-images\image-20191129161255985.png)

```js
Object.prototype.name = "ww";
function CreateStudent() {
	this.name = "zs";
	this.age = age;
}
CreateStudent.prototype.name = "ls";
CreateStudent.prototype.studying = function() {
	console.log(this.name + "Zhengzaixuexi");
}
var stu1 = new CreateStudent();
console.log(stu1.name);
// 实例对象找属性，先找构造函数里面的属性 如果构造函数里面没有这个属性 
===> 去当前构造函数的原型上面找 
    ===> 如果当前构造函数原型上没有这个属性 
    	===>去当前构造函数原型(CreateStudent.prototype)的构造函数的Object原型(Object.prototype)
```



### 12.2

##### 正则表达式

```js
传统方法：
var str = 'haj123sdk54hask33dknalsd789';
// ["123","54","33","789"]
//'0 4 8 9 2 5' "0" 49 "9" 57 我们可以通过数字的字符编码来判断是否是数字字符串
// 循环字符串 看一下每个字符是不是数字（是不是在49-57编码范围内）

var arr =[];
// 用来拼接连续的数字
var newStr = '';
for(var i = 0;i < str.length;i++) {
	if(str.charCodeAt(i) >= 49 && str.charCodeAt(i) <= 57) {
		// 数字字符串
		newStr += str[i]; // "123"
	}else{
		if(newStr) {
			// 进来else 说明不连续，把之前if里面累加的newStr存入arr中
			arr.push(newStr);
			// 把newStr清空，以便于下一次重新拼接新的连续的数字
			newStr = "";
		}
	}
}
if(newStr) {
    arr.push(newStr);
}
console.log(arr);

正则表达式方法：
// 连续匹配一个或者多位的数字
console.log(str.match(/\d+/g));
```

```
正则：也叫规则，是计算机能够读懂人类的规则，正则表达式，Regular Expression

正则都是用来操作字符串的，它是一个字符串的匹配工具，它是独立的一部分

正则在js当中是一个内置对象 new RegExp()

正则的两种声明方式：

1 简单声明式 推荐

​	/adbdc/

2 标准声明式

​	new RegExp() 构造函数声明方式 function RegExp() 
```

###### test方法

``````js
test：用来匹配字符串的方法
返回一个布尔值，如果匹配到了则返回 true 否则匹配不到，返回 false
用法： 正则.test(字符串)
// 正则严格区分大小写
// 转义字符 d       \d 匹配任意的数字

var str1 = 'abged';
// 定义一个正则规则 RegExp re
var re = /a/;

console.log(re.test(str1));// true

var str2 = 'dgae3cav';
if(/\d.test(str2)) {
   alert('yes')
}else{
   alert('no')
}
``````

###### search方法

```js
search：匹配字符串的方法，搜索方法，如果匹配到则返回对应的位置（下标）
		如果匹配不到则返回 -1
用法：str.search(正则)
正则两个匹配模式： i (ignore 忽略) 忽略大小写
				g (global) 全局匹配 把整个字符全部匹配一遍
正则中默认严格区分大小写 只要不匹配到，则不会继续匹配
// search方法 支持 i 忽略大小写  g(全局匹配)不支持

var str = "helloworld";
var re1 = /h/;

console.log(str.search(re1)); // 0
```

###### match方法

```js
match：匹配字符串的方法，返回一个数组
用法：str.match(正则)
// 即支持 i 也支持 g
var str = 'haj123sdk54hask33dknalsd789';
console.log(str.match(/\d+/g));// ["123"]
var str2 = 'bdeZZzaZgq';
var re = /z+/ig; // + 量词 连续匹配一位或者多位
console.log(str2.match(re));// ["ZZz","Z"]

// 如果不是全局匹配则会返回这样一个数组形式
// [匹配到的字符，index：该字符的下标位置， input：整个字符串，groups：undefined]
// ["1",index:3,input:'haj123sdk54hask33dknalsd789',groups:undefined]
// 如果是全局匹配则会把所有匹配到的字符串存入数组，以数组的形式返回
// ["1","2","3","4","5","6","7","8","9"]
```

###### replace方法

```js
replace：替换方法，匹配字符串，把匹配到的字符串替换成新的字符串
用法：str.replace(正则，替换成的字符串)

var str = "我是前端";
var re = /前端/;
console.log(re.test(str));
var result = str.replace(re,"后端");

var str2 = 'aabceAaswa';
var re2 = /a+/ig;
var result = str2.relpace(re2,"z");
console.log(result);// 'zbcezswz'
```

###### 日期格式化

```js
var str = '2019-12-2';
// 2019/12/2
var result = str.split("-").join("/");
console.log(result);

var result = str.replace(/-/g,"/");
console.log(result);

var re = /(\d+)-/g;
var result = str.replace(re,function($0,$1) {
    console.log($0);// 每次匹配到的项 2019- 8-
    console.log($1);// 每次匹配到的项的第一小组 2019  8
    
    return $1 + '/'
})
console.log(result);
```

###### 转义字符重复子项

```js
. 任意字符 \. 表示.本身
\d  \D
\w  \W
\s  \S
\b  \B

// \1 第一子项
var str = 'adadfaeesesswssfwrssrrsfs';
// 找重复最多的字符和个数
// 把字符串通过空字符分割转换为数组
var arr = str.split(""); // ["a","d","a","d"]
// 把数组里面的每一个字符进行排序 sort 默认按照字符编码排序
arr.sort()
// 把数组通过空字符连接转回去
var newStr = arr.join("");
console.log(arr);
console.log(newStr);

// 写一个正则
// .通过括号括起来，形成第一小组
// \1 代表和第一小组一样
// + 量词 匹配连续一个或者多个
// *量词 匹配连续0个或者1个或者多个 任意个
var re = /(.)\1*/g;
// 设置一个变量用来找重复次数最多的字符 
var str = "";// 记录字符
var maxNum = 0;// 记录该字符重复次数
newStr.replace(re,function($0) {
    console.log($0)
    if(maxNum < $0.length) {
        maxNum = $0.length;
        str = $1
    }
})
console.log('重复次数最多的字符是' + str + '重复了' + maxNum + '次');
```

###### 量词

```js
+ 匹配1个或者多个
* 匹配连续0个或者1个或者多个 任意个
? 匹配0个或者1个
用 {} 来表示量词
{n,m} 至少匹配n次 最多匹配m次
{n} 正好匹配n次

定界符 ^:[^排除的意思] 放到外面 代表的是以什么什么开头
	  $ 以什么结尾
```



##### Ajax

> ajax：一种前后端数据交互的一种方法/方式
>
> 异步：不同于同步，是一个非阻塞的形式
>
> 主要作用：数据交互
>
> ajax的特点优点：
>
> 1 节省用户操作时间，提高用户体验，减少数据请求（好处）
>
> 2 传输获取数据（作用）



###### 前后端数据通信

 ![image-20191202165154534](C:\Users\97201\AppData\Roaming\Typora\typora-user-images\image-20191202165154534.png)

```js
// 用户访问某个网站
// 1 打开浏览器 ==> 2 输入网址 ==> 3 按下回车 ==> 4 等着数据回家，页面呈现出来

// 演示一下 ajax 请求
// 请求一个文本文件 ajax.txt
// 1 创建一个ajax对象（ajax是一个js的内置对象，需要通过new产生）
var xhr = new XMLHttpRequest() // XMLHttpRequest构造函数

// 2 通过xhr对象调用open() 设置一个请求信息
// 参数1：请求方式get/post
// 参数2：请求地址 后端 data.php ...
// 参数3：是否异步 true 异步 false 同步

// 3 发送请求
xhr.send();

// 4 接收返回的数据
xhr.onreadystatechange = function() {
    if(xhr.readyState == 4) {
        console.log(xhr.responseText);
    }
}
```



###### ajax的创建对象过程

```js
// 异常捕获/容错语句 try...cacth(e){}
try{
	// 尝试运行里面的代码，如果有错误/异常，则会进入catch语句中
	var a = 10;
	alert(a);
	alert(b);// b is not defined 
	if(true) {
		//  new Error() 产生一个错误对象
		throw new Error('这里错了')
	}
}catch(e){ // e代表这try语句中的错误信息
	console.log(e);
}
alert('代码可以运行');

// 通过try catch语句去处理创建过程兼容性
var xhr = null;
try{
	xhr = new XMLHttpRequest();
}catch(e) {
	xhr = ActiveXObject('Microsoft.XMLHTTP')
}
```



###### ajax的open方法

~~~js
// 通过try catch语兼容
var xhr = null;
try{
	xhr = new XMLHttpRequest();
}catch(e) {
	xhr = ActiveXObject('Microsoft.XMLHTTP')
}

// 调用ajax对象的open方法
// 参数1：请求方式get/post
// 参数2：请求地址（绝对地址/相对地址）
// 参数3：是否异步 true 异步 false 同步

// 前端ajax请求数据（异步） 表单（同步） 通提交把数据发送到后端
xhr.open();
~~~



###### 表单提交数据

```js
/*
表单：
	action:请求地址 get.php
	method:请求方式 get
	enctype:表单数据提交的编码类型
		application/x-www-form-urlencoded:表单的数据变为键值对
		text/plain:纯文本
		multipart/form-data:含有非文本内容，比如音频文件
*/
/*
get请求：
	1 请求的数据通过url地址传输后端
	通过 ? 加数据（键值对 name=zs）进行拼接
	每条数据之间通过 & 符合去连接
	2 由于url地址长度有限制，不同浏览器限制不一样
	3 安全性相对较差，url地址会被浏览器缓存，一些请求数据就会被看到
*/


<form action="get.php" method="get" enctype="application/x-www-form-urlencoded">
	用户名：<input type="text" name="username">
	密码：<input type="password" name="password">
	<input type="submit" value="提交">
</form>


/*
post请求：
	1 会把请求携带的数据放到请求体的formdata当中进行传输
	2 理论上没有限制 一般后端服务器有限制
	3 相比get更安全一些
*/

<form action="get.php" method="post" enctype="application/x-www-form-urlencoded">
	用户名：<input type="text" name="username">
	密码：<input type="password" name="password">
	<input type="submit" value="提交">
</form>
```



###### 同步与异步的区别

```js
/*
同步：前面代码会阻塞后面的代码运行
异步：前面代码不会阻塞后面的代码运行

js 在前端dom操作当中是同步，同一个执行路线
js setInterval() setTimeout()方法是异步操作
*/

alert(123);
setTimeout(function() {// 异步操作
	alert(789);
},1000)
alert(456);
```



###### ajax的状态码

```js
onreadystatechange事件 当准备状态发生改变的时候触发
	readyState属性：请求状态 ajax工作状态
	0 （初始化）还没有调用open()方法 （已经创建ajax对象）
	1 （载入）已调用open()方法，正在发生请求
	2 （载入完成）send()方法完成，已收到全部响应内容
	3 （解析）正在解析响应内容
	4 （完成）响应内容解析完成，可以在客户端调用了
	
status属性：服务器（请求资源）的状态，http状态码
返回的内容
	responseText：返回文本形式存放的内容
	responseXML：返回XML形式的内容
```



### 12.3

###### 传输过程中的注意事项

```js
get方法：
1.在某些浏览器（IE 9 8...）中文不识别问题/产生乱码
解决方式：把中文进行编码处理 encodeURI() decodeURI() 解码
2.如果后端请求文件发送改动，某些浏览器在不刷新浏览器情况下，请求的数据会被缓存，解决缓存问题（这一次和上一次的请求同一个地址）
解决方法：这次和上次不一样，每次请求的时候后面加一个时间戳 newDate().getTime();

post：没有缓存问题，请求头中设置了 文件编码类型，则没有中文乱码问题
```

```js
// 常规 ajax 请求
$.ajax({
	type:"post",
	url:"aa.py",
	data:"",
	dataType:"json",
	success:fuction(data) {
		//不同的处理
	}
	error:function(e) {
		console.log(e);
	}
})

$.ajax({
	type:"post",
	url:"aa.py",
	data:"",
	dataType:"json",
}).then(function(data) {
    console.log(data);
})
```



###### ajax的跨域问题

```js
跨域：同域是要保证同一域名、同一端口、同一协议，任何一种不一样都属于跨域
跨域的问题：
	ajax不能跨域
	出于浏览器的限制（浏览器内部有一个同源策略）
目前实际跨域的解决方法：
	1 后端脚本代理（前端不能跨域，但是后端可以跨域，前端先请求同域下后端文件，由后端文件去直接请求那个需要跨域的文件）
	2 nginx服务器反向代理（了解：nginx可以设置跨域请求）用的多
	3 flash插件（已经淘汰flash插件，可以携带数据进行跨域访问，苹果移动设备 h5 css3 js）
	4 后端设置运行跨域（用的多一些）
	5 jsonp（一种跨域解决方案）：json width padding（也用，但是需要后端支持）
	6 前端的一些小手段（window.name iframe postMessage）
```



##### jsonp

###### jsonp图示

![image-20191203175713667](C:\Users\97201\AppData\Roaming\Typora\typora-user-images\image-20191203175713667.png)

###### jsonp原理

~~~js
jsonp：json width padding
	它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）
	JSONP就像是JSON+Padding一样(Padding这里我们理解为填充)

// JSONP的实现模式--callback
程序A中的部分代码：

<script>
//回调函数
function callback(data) {
    alert(data.message);
}
</script>
<script src="http://localhost:20002/test.js"></script>

程序B中的代码：

//调用callback函数，并以json数据形式作为阐述传递，完成回调
callback({message:"success"});

这其实就是JSONP的简单实现模式，或者说是JSONP的原型：创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调。
~~~



### 12.4

##### ES6

###### 变量

```js
var
1 可以重复声明
2 无法限制修改
3 没有块级作用域

let  const 
1 都不能重复声明变量
2 const 用来声明常量，一般建议大写
let声明的变量，不会在window下挂载
```



###### 箭头函数

```js
函数-箭头函数
function 名字() {
    
}

()=>{
    
}

1 如果只有一个参数，()可以省
2 如果只有一个return，{}可以省

let abc = function(str) {
    return str.substring(1,3);
}
let ret = abc("hello");
alert(ret);

let abc = str => str.substring(1,3);
let ret = abc("hello");
alert(ret);


let dd = (a,b) => a + b;
alert(dd(10,12));


window.onload = function() {
    console.log(document.getElementById("box"));
}

onload = () => console.log(document.getElementById("box"));

```



###### 解构赋值

```js
解构赋值：
1 左右两边结构必须一样
2 右边必须是个东西
3 声明和赋值不能分开

var a = 10;
var b = 15;
var [a,b] = [b,a];
console.log(a.b); // a:15 b:10

let [a,b,c] = [3,6,9];
let {age,name} = {name:"张三",age:24}
console.log(a,b,c);
console.log(age,name);

// 复杂解构
let [{a,c},[n1,n2,n3],num,str] = [{a:"hehe",c:"xixi"},[7,-9,23],55,"hello"]
console.log(a,c,n1,n2,n3,num,str);

let [json,arr] = [{a:"hehe",c:"xixi"},[7,-9,23],55,"hello"]
console.log(json,arr);
```



###### Rest Parameter(扩展运算符)

```js
rest参数
1 参数扩展/数组展开
2 默认参数

// ...args
// 函数参数的扩展，收集剩余参数
let show = (a,b,...args) => {
    console.log(a);
    console.log(b);
    console.log(args);// [把剩余的参数收集起来]
}
show(3,6,8,13,22,-9);

// 函数传参的展开，实际参数的传入
let arr1 = ["red","blue","green"];
let abc = () => {
    console.log(a);
    console.log(b);
    console.log(c);
}
abc(...arr1);// "red","blue","green"

// 利用rest参数多个数组合并
let arr2 = [5,6,7];
let arr3 = [8,9,0];
console.log([...arr2,...arr3]);// 5,6,7,8,9,0

// rest参数嵌套调用
let a = (...args) => {
    b(...args)
}

let b = (...args) => {
    // 求和
    var num = 0;
    for(var i = 0;i < args.length;i++){
        num += args[i];
    }
    alert(num)
}
a(12,6,8);
a(8,3,9,-1);
```



###### 数组新增的方法

```js
map 映射
let = [a,b,c];// a:{name:"zs",age:24} b:{name:"ls",age:30} 

// 数组每个元素乘以2
let arr = [1,2,3,4,5];// [2,4,6,8,10]
let ret = arr.map(function(ele,i) {
    return ele*2;
})
console.log(arr.map(ele => ele*2));

console.log(arr)
console.log(ret)

// 数组分数映射是否及格
let score = [48,67,86,35,59,99];
console.log(score.map(function(ele) {
    if(ele >= 60) {
        return "及格"
    }else{
        return "不及格"
    }
}));
console.log(score.map(ele => ele >= 60 ? "及格" : "不及格"));


filter 过滤
let aa = [3,5,18,14,27,31];
// 保留3的倍数，去掉不是3的倍数的数
let ret = aa.filter(function(a,b) {
    if(ele%3 == 0) {
        return true;
    }else{
        return false;
    }     
});
console.log(ret)
console.log(aa.filter(ele => ele%3 ==0 ? "true" : "false"));

// 判断价格
let arr = [
    {name:"洗发水",price:580},
    {name:"洗衣机",price:12000},
    {name:"电视",price:23000},
    {name:"冰箱",price:8888}
]
consolr.log(arr.filter(ele => ele.price > 10000 ? "true" : "false"));


forEach 迭代遍历
let aa = [1,3,4,5,8,7,5,2,-7,5,88];
let str = "";
aa.forEach((ele,i) => {
    str += `<li>${i}====${ele}</li>`
})
document.body.innerHTML = str;


reduce 汇总
let arr= [13,14,16,17,18];
let ret = arr.reduce(function(a,b,c) {
    console.log(a,b,c); // 13 14 c:1
    // underfined
    
    // a:方法内部每次返回的值
    // b:每次循环的值
    // c:循环次数
    return a + b; // 13 + 14 == 27 27 + 16 == 43 43 + 17 == 60 60 + 18 == 78
})
console.log(ret);

// 求平均值，在函数内部实现
let arr= [13,14,16,17,18];
console.log(arr.reduce((sum,ele,i) => {
	if(i == arr.length-1) {
        return (sum + ele) / arr.length;
    }else{
        returen sun + ele;
    }
}));

// let arr2 = [1,2,3,4,5];
// console.log(arr2.reduce((a,b) => a - b));
```



###### 字符串新增的方法

```js
includes(content)
// 用来检测是否包含指定的内容，如果包含，则返回true，否则返回false
let srt1 = "hello";
console.log(st1.includes("aa"));

startsWith(content)
// 用来检测是否以指定的内容开头，如果是，则返回true，否则返回false
console.log(st1.startsWith("a"));

endsWith(content)
// 用来检测是否以指定的内容结束，如果是，则返回true，否则返回false
console.log(st1.endsWith("o"));

repeat(times)
// 将字符串重复指定的次数并返回
console.log(st1.repeat(3));
```



###### 面向对象

~~~js
// 创建一个对象，构造函数来创建
// 箭头函数不能用在构造函数中
// 传统写法
function User(name,pass) {
	this.name = name;
	this.password = pass;
}
User.prototype.showName = function() {
	alert(this.name);
}
User.prototype.showPass = function() {
	alert(this.password);
}
var user1 = new User("zs",123456);
var user2 = new User("ls",178778);
user1.showName();
user2.showPass();


// es5: clss是保留字（className）
// class 关键字 定义类
// 新式写法
class User {
    constructor(name,pass) {
        this.name = name;
	    this.pass = pass;
    }
    showName() {
        alert(this.name);
    }
    showPass() {
        alert(this.pass);
    }
}
let u1 = new User("zs",123456);
let u2 = new User("ls",178778);
u1.showName();
u2.showPass();
~~~



###### 面向对象-继承

```js
// 创建一个对象，构造函数来创建
// 箭头函数不能用在构造函数中
// 传统写法
function User(name,pass) {
	this.name = name;
	this.password = pass;
}
User.prototype.showName = function() {
	alert(this.name);
}
User.prototype.showPass = function() {
	alert(this.password);
}
var user1 = new User("zs",123456);
var user2 = new User("ls",178778);
user1.showName();
user2.showPass();

function VipUser(name,pass,level) {
    User.call(this,name,pass)
    this.level = level;
}
for(var k in User.prototype) {
    VipUser.prototype[k] = User.prototype[k];
}
VipUser.prototype.showLevel = function() {
    alert(this.level);
}
let vip1 = new VipUser("haha",555,444);
vip1.showName();
vip1.showPass();
vip1.showLevel();


// es5: clss是保留字（className）
// class 关键字 定义类
// 新式写法
class User {
    constructor(name,pass) {
        this.name = name;
	    this.pass = pass;
    }
    showName() {
        alert(this.name);
    }
    showPass() {
        alert(this.pass);
    }
}
let u1 = new User("zs",123456);
let u2 = new User("ls",178778);
u1.showName();
u2.showPass();

class VipUser extends User {
    constructor(name,pass,level) {
        super(name,pass); // super 继承父类的属性和方法
        this.level = level;
    }
    showLevel() {
        alert(this.level);
    }
}
let vip1 = new VipUser("zs",12345,321);
vip1.showLevel();
vip1.showName();
vip1.showPass();
```



##### H5

###### 新增的表单类型

```html
<!-- 邮箱类型，内部会有一个正则验证 -->
<label>
    <input type="email">
</label>

<!-- 手机号码，当这个框框获取焦点后,移动端会弹出数字键盘 -->
<label>
    <input type="tel">
</label>

<!-- 网址，内部会有一个简单正则验证，网址协议 -->
<label>
    <input type="url">
</label>

<!-- 数字框，当这个框框获取焦点后,移动端会弹出数字键盘 -->
<label>
    <input type="number">
</label>

<!-- search类型，会把键盘的enter改成搜索两个字 -->
<label>
    <input type="search">
</label>

<!-- 范围选择 -->
<label>
    <input type="range" max="100" min="0" value="80">
</label>

<!-- 拾色器 -->
<label>
    <input type="color">
</label>

<!-- 时间类型 -->
<label>
    <input type="time">
</label>

<!-- 日期框 -->
<label>
    <input type="date">
</label>

<!-- 日期时间框 -->
<label>
    <input type="datetime-local">
</label>

<!-- 月份 -->
<label>
    <input type="month">
</label>

<!-- 周 -->
<label>
    <input type="week">
</label>
```

```html
<!-- 新属性
placeholder 占位符
autofocus 获取焦点
required 验证条件，必填项
Pattern 正则验证 pattern="\d{1,5}"
-->
<input type="text" placeholder="请你输入内容：" autofocus>
```



###### 本地存储sessionStroage和localStroage

```js
/*
sessionStroage 会话存储（会话结束之后过去，当前窗口关闭之后过期）
localStroage 永久存储（会把数据存入硬盘）
它本身提供了三个方法，方便操作
sessionStroage 5M     localStroage 20M
*/
sessionStroage.getItem("username","zs");
alert(sessionStroage.getItem("username"));
sessionStroage.removeItem();
sessionStroage.clear();

localStroage.getItem("age",30);
alert(localStroage.getItem("age"));
localStroage.removeItem();
localStroage.clear();
```



###### 地理定位

> H5：地理定位
> watchPosition 监控你的位置变化
> getCurrentPosition



###### 文件读取对象

```js
/*
FileReader 本质上是构造函数/类，通过new来产生一个文件读取对象
通过文件读取对象，可以读取一些数据，做一些相关操作（图片上传）
*/

var fr = new FileReader();// fr 文件读取对象

/*
读取文件时间有以下几个方法，几种形式
1 readAsText()
	以纯文本的形式来读取数据，返回字符串类型数据，默认是utf-8编码
2 readAsBinaryString()
	以二进制字符串的形式读取内容，可以读取任何数据类型，一般不给用户展示
    是用来传给后端直接存储的
3 readAsDataUrl()
	以dataUrl方式去读取文件 dataURL：base64格式（以data:开头的一种数据）
    这种数据形式可以直接嵌入html文档中展示给用户看
    我们读取图片使用这种
    方式，把图片读取成base64格式，直接放入img的src中展示给我们的用户看
    如果是以base64格式的信息放入src的，从某种程度上来说，是一种图片优化手段
    base64格式的图片，只需要加载一次就可以了，不需要反复从服务器加载图片（嵌入到文档中）
*/
```



### 12.10

##### 组件

###### 组件注册

```js
/*
1 全局注册：全局注册的组件，在所有位置（vue）都可以使用，注册必须放在根实例之前。
	vue.component
2 局部注册：在组件内注册，只有在当前注册的组件中才可以使用该组件。

DOM模板：视图写在html标签元素中，使用el属性与vue实例进行关联，多用在根组件中。
字符串模板：写在 template 属性值后面的字符串中多用在子组件。
	
组件命名：组件名可以使用驼峰或者 - (横杠)，驼峰命名只有在字符串中才能被识别，命名使用横杠可以在DOM或字符串模板中都可以使用。

data 组件中的 data 是一个返回对象的函数，数据定义在返回的对象中。
根实例中可以用的指令和方法在组件中同样可以使用。
*/
```

###### 动态组件

```html
使用 <compmonent> 配合 is 特殊属性使用
```

###### 动态组件的缓存

```html
使用 <keep-alive>,只有当第一次加载组件时才会创建改组件的实例，后续动态组件再次激活时将使用缓存的组件
```

###### prop 传递数据

```
通过 prop 父组件可以向子组件传递数据
在 dom 模板中使用 prop 属性时不允许驼峰命名，字符串模板中是可以的
```

###### 单向数据流

```
父级组件可以向子级组件传递，但子级组件不能通过 prop 传递数据给父级
```

###### 插槽

```html
<slot></slot>
插槽：父组件可以向子组件传递数据
 
`<template v-slot:tp2>`
具名插槽：带有名称的插槽
	给组件传递数据时使用 `<template v-slot:tp2>`  `v-slot` 指令后跟的就是插槽的名称
    在组建内部使用时 `<slot name="tp1"></slot>` 内置组件必须在 name 中标明所使用的插槽名称
 
prop 通过属性方式向子组件传递数据，插槽是通过标签值的方式向子组件传递数据
```



### 12.11

###### 自定义事件

```js
利用自定义事件可以让子组件向父组件传递数据
	触发自定义事件使用 `this.$emit()`（触发当前实例上的事件，附加参数都会传给监听器回调）
```

###### 脚手架 CLI

```js
	2.x  3.x
1.安装 `nodejs`
2.安装node时会自动安装npm
	`npm --version`
2.x CLI
	- `npm install vue-cli -g`
	- `vue -V` 查看版本
    CLI 创建工程
        - `vue init webpack xx-xx`
        - `npm run dev` 或 `npm start` 启动项目（必须在项目的根目录下执行该命令）
    CLI 2.x工程打包
        - `npm run build`
        打包完成后，在项目根目录会生成一个 `dist` 目录，该目录中的内容就是要部署到服务器的代码
        如果部署到服务器时并不是服务器的根目录，需要修改配置 `config\index.js` 中的 `build` 选项中的 `assetsPublicPath:'./' `
    CLI 2.x 与 3.x 只能安装一个
    卸载 2.x `npm uninstall vue-cli -g`
    卸载 3.x `npm uninstall @vue/cli -g`

- 2.x CLI 工程结构
	- `package.json`
		- `dependencies` 项目依赖
         - `devDependencies` 开发依赖
     - `index.html` html主入口文件
     - `static` 静态资源
     - `node_modules` 工程中依赖的安装目录
     - `build` webpack 打包的相关配置
     - `config` webpack 配置目录
     - `src` 工作目录
     	- `main.js` js主入口文件
        - `App.vue` 主入口组件
        - `components` 编写的自己都应该放在这个目录中
        - `assets` 放资源文件

        
3.x CLI
	- `npm install @vue/cli -g`
	- `vue -V` 查看版本
	- `vue ui` 打开图形工具

- 3.x CLI 工程结构
	- `package.json`
		- `dependencies` 项目依赖
         - `devDependencies` 开发依赖
     - `node_modules` 工程中依赖的安装目录
     - `public` 静态资源，该目录内容不会被编译，打包只是复制
     	- `index.html` 主入口文件
     	- `src` 工作目录
            - `main.js` js主入口文件
            - `App.vue` 主入口组件
            - `components` 编写的自己都应该放在这个目录中
            - `assets` 放资源文件
```

###### 单文件组件

```js
单文件组件就是一个文件就是一个组件，文件后缀 `.vue`
`.vue` 中 html、css、JavaScript
	- `<template>` 组件视图（只能有一个根节点）
    - `<script>` 组件的逻辑及数据（JavaScript）必须 `export default`将组件导入给调用者， `export default`返回组件实例
    - `<style>` 组件视图中所用到的样式
    	- 为 `<style>` 添加 `scoped` 属性，这样组件中的样式只能在当前组件中使用
```

###### 组件生命周期

```js
`beforeCreate` 在实例初始化之后，数据观测（data observer）和event/watcher事件配置之前被调用。
`created` 在实例创建完成后被立即调用。然而挂载阶段还没开始，$el属性目前不可见。
	- 可以对data中的数据进行填充操作
`beforeMount` 在挂载开始之前被调用
`mounted` 挂载结束之后会被调用
`beforeUpdate` 数据更新时调用，发送在虚拟 DOM 打补丁之前（更新之前）
`updated` 更新完成后调用
`beforeDestroy` 实例销毁之前调用
	- 保存数据操作
`destroyed` Vue实例销毁后调用

不建议使用
`$destroy()` 强制卸载
`$forceUpdate()` 强制渲染
```

###### 父子组件嵌套时生命周期的调用

```js
/*
1.创建时
    父组件 beforeCreate
    父组件 created
    父组件 beforeMount
    子组件 beforeCreate
    子组件 created
    子组件 beforeMount
    子组件 mounted
    父组件 mounted
    
2.更新时：
父组件更新，子组件不更新
	父组件 beforeUpdate
	父组件 updated
	
父组件更新，子组件更新
	父组件 beforeUpdate
	子组件 beforeUpdate
	子组件 updated
	父组件 updated

3.销毁时：
	父组件 beforeDestroy
	子组件 beforeDestroy
	子组件 destroyed
	父组件 destroyed
*/
```

##### 混入

```js
局部混入：组件中使用 `mixin` 混入数据
混入（mixin）提供了一种非常灵活的方式，来分发Vue组件中的可复用功能，组件中的所有选项都可以混入。
1. 数据混入时（data）数据对象在内部会进行递归合并，数据有重复时以`组件中的数据优先`。
2. 生命周期钩子函数将合并为一个数组，都将被调用，`混入对象的生命周期钩子函数将优先调用`。
3. 值为对象的选项，例如 methods、components和directives，`对象中成员有重复时组件中优先`。

全局混入：`Vue.mixin()`，必须放在new Vue()根实例之前
	一旦使用全局混入，它将影响每一个之后创建的Vue实例。
```



### 12.12

##### 自定义指令

```js
1.全局注册指令
	- `Vue.directive()` 
2.局部注册指令
	- 组件内使用 `directives` 注册指令
```

###### DOM操作

```js
使用 `ref` 在标签上或组件中绑定一个字符串，那么在父级组件中使用 `$refs` 就可以获取到这个 `DOM`
如果要在生命周期函数中使用请在 `mounted` 中使用
```



##### 路由(Vue-router)

```js
Vue Router 单页面应用程序
1.在组件中设置路由出口 `<router-view>`
2.设置路由规则：`routes`
const routes = [
    {path:'/home',component:Home}
]
3.根据路由规则实例化路由对象：`new VueRouter({routes})`
4.将路由对象注入vue实例 `router`

`<router-link>` 渲染成为 a 标签
	- `exact-active-class` 精确匹配（匹配 / 后面的字符） 路由规则匹配成功会给当前的 `<router-link>` 渲染的 a 标签添加一个类名
    - `active-class` 普通匹配
    以上两个属性如果设置在 `<router-link>` 时需要每个都设置，可以在实例化路由对象中统一设置：
    	`linkActiveClass`
    	`linkExactActiveClass`
    - `exact` 设置当前规则匹配时所对应的类名，是否是精确模式
    
/* 路由规则：只要匹配成功后面的规则将不再执行 */
    路由重定向
    {path:'/*',redirect:'/'}
```

###### 动态路由

```js
一个“路径参数”使用冒号 : 标记。
例如：`{path:'/user/:id',copmonent:User}`,像 /user/foo和 /user/bar都会匹配到该路由规则，路径参数在组件中可以通过 `$route.params`获取
```

###### 嵌套路由

```js
在路由规则所对应的组件中再放入一个路由出口，也就是路由包含了子路由
// 嵌套路由
{
    path:'/about',component:About,
    // 子路由配置
    children:[
        {path:'ft',component:Fruits},
        {path:'vt',component:Vegetables},
        // 重定向
        {path:'/',redirect:'ft'}
    ]
}
```

###### 编程式导航

```js
除了使用 `<router-link>` 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。
使用js的方式控制路由的跳转
`this.$router.push()` 跳转到指定路径或名称的路由规则
// 字符串
router.push('home')
// 对象
router.push({ path: 'home' })
// 命名的路由
router.push({ name: 'user', params: { userId: '123' }})
// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})

`this.$router.replace()` 
跟 `this.$router.push()` 很像，唯一的不同就是，它不会将跳转页面加入到页面栈中

`this.$router.go(n)`
// 在浏览器记录中前进一步，等同于 history.forward()
router.go(1)
// 后退一步记录，等同于 history.back()
router.go(-1)
// 前进 3 步记录
router.go(3)
```

###### 命名路由

```js
`命名式路由就是在路由规则中指定name属性，在使用编程式导航时可以通过这个name属性进行页面的跳转`
```

###### 命名视图

```js
命名视图就是在一个组件中有多个路由的出口，并且每个 `<router-view>` 都拥有 `name` 属性。在设置路由规则时需要使用 `components` 属性为每一个路由的出口指定所要渲染的组件。
```

###### 滚动行为

```js
在路由实例中设置 `scrollBehavior` 的返回值可以设置路由页面在跳转后的默认位置
```

###### 路由懒加载

```js
把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件
结合 Vue 的异步组件和 Webpack 的代码分割功能，实现路由组件的懒加载
`component:() => import('./views/About.vue')`
`component:() resolve => require(['./views/About.vue'], resolve)`
路由懒加载中 `import` 和 `require` 都可以实现路由的懒加载，推荐使用 `import`
```

###### 导航守卫

```js
完整的导航解析流程
1.导航被触发。
2.在失活的组件里调用离开守卫。
3.调用全局的 beforeEach 守卫。
4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
5.在路由配置里调用 beforeEnter。
6.解析异步路由组件。
7.在被激活的组件里调用 beforeRouteEnter。
8.调用全局的 beforeResolve 守卫 (2.5+)。
9.导航被确认。
10.调用全局的 afterEach 钩子。
11.触发 DOM 更新。
12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
```



### 12.13

#####  **状态管理模式** (Vuex)

> Vuex是一个专为 Vue.js 应用程序开发的状态管理模式
> 用户管理 Vue 中的数据，用于数据共享

###### State

> 用于存储数据，并且是 Vuex 唯一存储数据的对象
>
> 要访问 `state` 中的数据使用 `$store.state.xxxx`

###### Mutation

> 用于修改 `state` 中的数据且只能在 **Mutation** 修改
>
> 触发 Mutation 中方法使用 `$store.commit(name,args)`
>
> 	- 第一个参数为要触发的方式名称，字符串类型（必填）。
> 	- 第二个产生为传递给触发方法的参数，任意类型（选填）。建议使用对象（对象中可以封装多个数据）

###### Action

> 用于批量提交 **Mutation** 
>
> 触发 action 中方法使用 `$store.dispatch(name,args)`
>
> 	- 第一个参数为要触发的方法名称，字符串类型（必填）。
> 	- 第二个产生为传递给触发方法的参数，任意类型（选填）。建议使用对象（对象中可以封装多个数据）

###### Getter

>  就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 
>
> 使用 `getters` 中数据 `$store.getters.xxxx`

###### Module

> 开发工作中将每个组件都切割为独立的模块，每个模块中都有 `state` `mutation` `getters` `action` 对象，为方便每个模块将作为独立的文件存储，将该文件以模块的形式注入到 Vuex 实例对象中。
>
> *为了开发便利，在使用模块开发时需要开启 **namespaced** 命名空间*。
>
> 开启命名空间后访问 Vuex 中方法时需要加**模块前缀**
>
> ```js
> // 使用 getters
> {{$store.getters['Home/getText']}}
> // 触发 mutation
> this.$store.commit('Home/setText',{text:this.homeText})
> // 触发 action
> this.$store.dispatch('Home/setTextAction',{text:this.homeText})
> ```



##### 实例上的方法

```js
this.$data // vm上的数据
this.$watch // 监控
this.$el // 当前el元素
this.$set // 后加的属性实现响应式变化
this.$options // vm上的所有属性
this.$nextTick(() =>{ // 异步方法，等待渲染dom完成后来获取vm})
this.$refs // 如果dom元素不是通过v-for循环出来的只能获取到一个，通过v-for循环出来的数据可以获取多个
```



